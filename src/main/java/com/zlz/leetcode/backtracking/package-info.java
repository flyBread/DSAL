/**
 * @author zhailz
 *
 *         时间：2016年10月27日 ### 下午3:36:11
 */
package com.zlz.leetcode.backtracking;

/**
 * 回溯算法：
 * 回溯法（英语：backtracking）也称试探法，回溯法有“通用的解题方法”之称。
 * 它可以系统的搜索一个问题的所有解或者任意解。
 * 
 * 回溯法是一个既带有系统性又带有跳跃性的的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点
 * 
 * 出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过
 * 
 * 对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来
 * 
 * 求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而回溯法在用来求问题的任一解时，只要搜索到问题
 * 
 * 的一个解就可以结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题.
 * 
 * 回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：
 * 
 * 1 .找到一个可能存在的正确的答案。
 * 
 * 2. 在尝试了所有可能的分步方法后宣告该问题没有答案。
 * 
 * 在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。
 * 
 * 在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。
 * 
 * 适用范围：
 * 
 * 1，问题的解用向量表示
 * 
 * X = (x1, x2, ..., xn)
 * 
 * 2，需要搜索一个或一组解
 * 
 * 3，满足约束条件的最优解
 * 
 * 回溯法的基本思想
 * 
 * 对于用回溯法求解的问题，首先要将问题进行适当的转化，得出状态空间树。这棵树的每条完整路径都代表了一种解的可能。通过深度优先搜索这棵树，
 * 枚举每种可能的解的情况；从而得出结果。但是，回溯法中通过构造约束函数，可以大大提升程序效率，因为在深度优先搜索的过程中，不断的将每个解（并不一定是完整的，
 * 事实上这也就是构造约束函数的意义所在）与约束函数进行对照从而删除一些不可能的解，这样就不必继续把解的剩余部分列出从而节省部分时间。
 * 回溯法中，首先需要明确下面三个概念：
 * 1，约束函数：约束函数是根据题意定出的。通过描述合法解的一般特征用于去除不合法的解，从而避免继续搜索出这个不合法解的剩余部分。因此，
 * 约束函数是对于任何状态空间树上的节点都有效、等价的。
 * 
 * 2，状态空间树：刚刚已经提到，状态空间树是一个对所有解的图形描述。树上的每个子节点的解都只有一个部分与父节点不同。
 * 
 * 3，扩展节点、活结点、死结点：所谓扩展节点，就是当前正在求出它的子节点的节点，在DFS中，只允许有一个扩展节点。活结点就是通过与约束函数的对照，
 * 节点本身和其父节点均满足约束函数要求的节点；死结点反之。由此很容易知道死结点是不必求出其子节点的（没有意义）。
 * 
 * 利用回溯法解题的具体步骤
 * 
 * 首先，要通过读题完成下面三个步骤：
 * 
 * (1)描述解的形式，定义一个解空间，它包含问题的所有解，这一步主要明确问题的解空间树。
 * 
 * (2)构造状态空间树。
 * 
 * (3)构造约束函数（用于杀死节点）。
 * 
 * 然后就要通过DFS思想完成回溯，具体流程如下：
 * 
 * (1)设置初始化的方案（给变量赋初值，读入已知数据等）。
 * 
 * (2)变换方式去试探，若全部试完则转(7)。
 * 
 * (3)判断此法是否成功（通过约束函数），不成功则转(2)。
 * 
 * (4)试探成功则前进一步再试探。
 * 
 * (5)正确方案还未找到则转(2)。
 * 
 * (6)已找到一种方案则记录并打印。
 * 
 * (7)退回一步（回溯），若未退到头则转(2)。
 * 
 * (8)已退到头则结束或打印无解。
 * 
 * 总结起来就是:
 * 
 * 针对所给问题，确定问题的解空间 --> 确定结点的扩展搜索规则--> 以DFS方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。
 * 
 * 回溯法基本框架
 * 
 * 设问题的解是一个n维向量(a1,a2,………,an),约束条件是b(i=1,2,3,…..,n)之间满足某种条件，记为f(bi)。
 * 
 * 递归实现：
 * int a[n];
 * 初始化数组a[]等操作
 * ...
 * void dfs(int cur)
 * {
 * int i;
 * if(cur>n)
 * //统计、输出结果等;
 * else
 * {
 * for(i = 下界; i <= 上界; ++i) // 枚举i所有可能的路径
 * {
 * if(fun(i)) // 满足限界函数和约束条件
 * {
 * a[cur] = i;
 * ... // 其他操作,设置标志等
 * dfs(cur+1);
 * //回溯前的清理工作（如a[cur]置空值,标志置0等）;
 * }
 * }
 * }
 * }
 * 
 * 下面是最近更新的回溯法的相关例子，http://blog.csdn.net/daniel_ustc/article/details/17041933。
 * 
 * http://zh.wikipedia.org/zh-cn/%E5%9B%9E%E6%BA%AF%E6%B3%95
 * 
 * http://www.newsjz.com/wxqgr/xxas/as2/sfjc/201103/337.html
 * 
 */
